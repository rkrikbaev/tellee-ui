<link rel="import" href="../polymer/polymer.html" />

<link rel="import" href="../px-d3-imports/px-d3-imports.html" />
<script src="d3-timelines.js"></script>
<script src="../d3/d3.min.js"></script>
<script>
  const d3v4 = d3;
</script>
<link rel="import" href="../px-theme/px-theme-styles.html">
<custom-style>
  <style include="px-theme-styles" is="custom-style"></style>
</custom-style>

<dom-module id="polymer-d3-timeline">
  <template id="template">
    <style type="text/css">
      #timeline path,
      .legend text,
      .timeline-xAxis line {
        stroke: var(--px-base-text-color, #383846) !important;
      }

      .timeline-xAxis text {
        fill: var(--px-base-text-color, #383846) !important;
      }
    </style>
    <div width="100%" id="timeline"></div>
  </template>
</dom-module>



<script>
  Polymer({

    is: 'polymer-d3-timeline',

    /**
     * Properties block, expose attribute values to the DOM via 'reflect'
     *
     * @property properties
     * @type Object
     */
    properties: {
      /**
       * Current value of the gauge.
       * @property value
       * @type {Array}
       * @default `0`
       */
      data: {
        type: Array,
        observer: '_changeGraph'
      },
      width: {
        type: Number,
        observer: '_changeWidth'
      },
      height: {
        type: Number,
        observer: '_changeHeight'
      }
    },

    _changeGraph: function() {
      this._changeHeight();
      this._changeWidth();
    },

    _changeWidth: function () {
      this.properties.width = this.width;
      d3v4.select(this.$$("#timeline svg")).remove();
      this.attached();
    },
    _changeHeight: function () {
      this.properties.height = this.height;
      d3v4.select(this.$$("#timeline svg")).remove();
      this.attached();
    },
    attached: function () {
      // If state equals null or have decimal part then:
      var errorDiv = d3v4.select(this.$$('#timeline'));
      for(let i = 0; i < this.data.length; i++) {
        if (!this.data[i].state || this.data[i].state - Math.floor(this.data[i].state) != 0) {
          errorDiv.selectAll('.error_msg').remove();
          errorDiv
            .append("p")
            .attr("class", "error_msg")
            .style("padding", "20px 40px")
            .style("margin", "0")
            .text("Error occured! You recieved invalid data...");
          return;
        } else {
          errorDiv.selectAll('.error_msg').remove();
        }
      }

      if (!this.width || !this.height) return;
      this.properties.data = this.data;
      var testData = [
        { times: this.properties.data },
      ];

      var chart = d3v4.timeliness();
      // chart.showTimeAxisTick({
      //   stroke: "stroke-dasharray",
      //   color: "#7A65F2"
      // })
      chart.itemHeight(this.properties.height - 100);
      var svg = d3v4.select(this.$$('#timeline'))
        .append("svg")
        .attr("width", this.properties.width)
        .attr("height", this.properties.height)
        .datum(testData)
        .call(chart);

      // =====================================

      // Declaring variables
      var values = [],
        colors = [];

      // give size to legend
      var _height = this.height;
      var _width = this.width;
      var legendSize = 13;

      // if diagram height greater than width
      if (this.height > this.width) {
        _height = this.width;
        _width = this.height;
      }

      // filtering 'states' array to be unique
      let count_data = {};
      let repeat = 1;
      for (let i = 0; i < this.data.length; i++) {
        if (count_data[this.data[i].state]) {
          count_data[this.data[i].state][0] += this.data[i].ending_time - this.data[i].starting_time;
          count_data[this.data[i].state][2] += 1;
        } else
          count_data[this.data[i].state] = [
            this.data[i].ending_time - this.data[i].starting_time,
            this.data[i].state,
            repeat,
            this.data[i].color,
            this.data[i].stateName
          ]
      }

      // for getting access to count_data's keys( which actually states )
      var arr = [];
      for (let key in count_data) {
        arr.push(key);
      }

      // creating data to 'domain()' and 'range()'
      for (let i = 0; i < arr.length; i++) {
        colors.push(count_data[arr[i]][3]);
        values.push(count_data[arr[i]][4]);
      }

      // pasting colors of legend
      var color = d3v4.scaleOrdinal()
        .domain(values)
        .range(colors);

      // positioning colors of legend
      var legend = svg.selectAll(".legend")
        .data(color.domain())
        .enter()
        .append("g")
        .attr("class", "legend")
        .attr("transform", function (d, i) {
          var height = _height + _width;
          var horz = i * 250 + 30;
          var vert = _height - 35;
          return "translate(" + horz + "," + vert + ")";
        });

      // giving size of color's retangle
      legend.append("rect")
        .attr("width", legendSize)
        .attr("height", legendSize)
        .style("fill", color)
        .style("stroke", color);

      // creating new array to get key of object
      var newCount_data = Object.keys(count_data).map((item, i) => (
        count_data[item]
      ));
      // common period equals: last state's ending_date - first state's starting_date
      var period = this.data[this.data.length - 1].ending_time - this.data[0].starting_time;

      // appending text to legend
      legend.append("text")
        .attr("x", function (d, i) {
          return i + 20;
        })
        .attr("y", 11)
        .style("font-size", 13)
        .style("font-weight", 200)
        .style("stroke", "#383846")
        .text(function (d, i) {

          var upperLegend = d ? d.toUpperCase() : 'NOT SET';
          var time = newCount_data[i][0] / 1000;
          let percents = 0, days = 0, hours = 0, minutes = 0;
          percents = ((newCount_data[i][0] * 100) / period).toFixed(2);

          if (!newCount_data[i][0]) return `${upperLegend} (few seconds, ${percents}%, ${newCount_data[i][2]}x)`;
          days = Math.round(time / 86400);

          hours = Math.round((time - (days * 86400)) / 3600);

          minutes = Math.round((time - (days * 86400) - (hours * 3600)) / 60);

          if (days > 1) {
            return `${upperLegend} (${Math.abs(days)} days, ${percents}%, ${newCount_data[i][2]}x)`;
          } else if (days == 1) {
            return `${upperLegend} (${days} day, ${percents}%, ${newCount_data[i][2]}x)`;
          } else if (hours >= 1) {
            return `${upperLegend} (${Math.abs(hours)} hours, ${percents}%, ${newCount_data[i][2]}x)`;
          } else if (minutes >= 1) {
            return `${upperLegend} (${Math.abs(minutes)} minutes, ${percents}%, ${newCount_data[i][2]}x)`;
          } else {
            return `${upperLegend} (few seconds, ${percents}%, ${newCount_data[i][2]}x)`;
          }
        });
    }

  });
</script>